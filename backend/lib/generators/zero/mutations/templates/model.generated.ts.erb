// ü§ñ AUTO-GENERATED ZERO MODEL - DO NOT EDIT
// Generated at: <%= Time.current.iso8601 %>
//
// ‚ö†Ô∏è  ‚ö†Ô∏è  ‚ö†Ô∏è  STOP! DO NOT EDIT THIS FILE! ‚ö†Ô∏è  ‚ö†Ô∏è  ‚ö†Ô∏è
//
// This file is automatically regenerated from your Rails ActiveRecord model.
// Any manual changes will be PERMANENTLY LOST on next generation.
//
// üîß TO MAKE CHANGES:
// 1. Edit the Rails model: app/models/<%= file_name %>.rb
// 2. Edit generator config: config/zero_generator.yml (if needed)
// 3. Edit generator template: lib/generators/zero/mutations/templates/
// 4. Run: rails generate zero:mutations
//
// üö´ NEVER EDIT GENERATED FILES DIRECTLY
// üîÑ TO REGENERATE: Run `rails generate zero:mutations`

import { getZero } from '../zero-client';
import { ReactiveQuery, QueryFactory, ZERO_CONFIG } from '../reactive-query-unified.svelte';

<% if needs_types? %>
// TypeScript interfaces generated from Rails model: <%= class_name %>

/**
 * Complete <%= class_name %> record as stored in database
 * Generated from Rails model: app/models/<%= file_name %>.rb
 */
export interface <%= class_name %> {
<% attributes.each do |attr| -%>
  <%= attr.name %>: <%= attr.typescript_type %>;
<% end -%>
}

/**
 * Data required to create a new <%= file_name %>
 * Excludes auto-generated fields (id, created_at, updated_at)
 */
export interface Create<%= class_name %>Data {
<% create_attributes.each do |attr| -%>
  <%= attr.name %>: <%= attr.typescript_type %>;
<% end -%>
}

/**
 * Data for updating an existing <%= file_name %>
 * All fields optional, excludes auto-managed fields
 */
export interface Update<%= class_name %>Data {
<% update_attributes.each do |attr| -%>
  <%= attr.name %>?: <%= attr.typescript_type %>;
<% end -%>
}

/**
 * Standard response from mutation operations
 */
export interface <%= class_name %>MutationResult {
  id: string;
}
<% end %>

<% if needs_mutations? %>
// CRUD mutations generated from Rails model validations and schema

<% crud_operations.each do |operation| -%>
/**
 * <%= operation.description %>
 * 
 * Generated from Rails model: <%= class_name %>
 * Rails validations: <%= operation.validations.join(', ') %>
 * 
 * @example
 * ```typescript
 * <%= operation.example %>
 * ```
 */
export async function <%= operation.name %>(
  <%= operation.parameters %>
): Promise<<%= class_name %>MutationResult> {
  const zero = getZero();
  
  // Validation from Rails model
<% operation.validations_code.each do |validation| -%>
  <%= validation %>
<% end -%>
  
  // Generate unique ID with validation
  const id = crypto.randomUUID();
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Failed to generate valid UUID');
  }

  const now = Date.now();

  try {
    await zero.mutate.<%= table_name %>.<%= operation.zero_method %>({
      <%= operation.zero_params %>
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to <%= operation.action %> <%= file_name %>: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

<% end -%>
<% end %>

// ActiveRecord-style queries generated from Rails associations and scopes

/**
 * ActiveRecord-style query interface for <%= table_name %>
 * Generated from Rails model: app/models/<%= file_name %>.rb
 * Associations: <%= associations.map(&:name).join(', ') %>
 * Scopes: <%= scopes.map(&:name).join(', ') %>
 * 
 * Provides Rails-compatible offline-capable queries with Zero's local database
 * Matches Rails ActiveRecord patterns: https://guides.rubyonrails.org/active_record_querying.html
 */
export const <%= class_name %> = {
  /**
   * Find a single <%= file_name %> by ID (like Rails <%= class_name %>.find(id))
   * @param id - The UUID of the <%= file_name %>
   * @returns ReactiveQuery with the <%= file_name %> or null
   * 
   * @example
   * ```typescript
   * const <%= file_name %> = <%= class_name %>.find('123e4567-e89b-12d3-a456-426614174000');
   * console.log(<%= file_name %>.record); // The <%= file_name %> object or null
   * console.log(<%= file_name %>.present); // true if found, false if null
   * ```
   */
  find(id: string) {
    return QueryFactory.forRecord<<%= class_name %>>(
      () => {
        const zero = getZero();
        return zero ? zero.query.<%= table_name %>
          .where('id', id)
<% associations.each do |assoc| -%>
          .related('<%= assoc.name %>'<%= assoc.options %>)
<% end -%>
          .one() : null;
      },
      { 
        ttl: '<%= find_ttl || ZERO_CONFIG.DEFAULT_TTL %>',
        defaultValue: null
      }
    );
  },

  /**
   * Get all <%= table_name %> (like Rails <%= class_name %>.all)
   * @returns ReactiveQuery with array of <%= table_name %>
   * 
   * @example
   * ```typescript
   * const all<%= class_name.pluralize %> = <%= class_name %>.all();
   * console.log(all<%= class_name.pluralize %>.records); // Array of <%= table_name %>
   * console.log(all<%= class_name.pluralize %>.present); // true if any records exist
   * ```
   */
  all() {
    return QueryFactory.forCollection<<%= class_name %>>(
      () => {
        const zero = getZero();
        return zero ? zero.query.<%= table_name %>
<% associations.each do |assoc| -%>
          .related('<%= assoc.name %>'<%= assoc.options %>)
<% end -%>
          .orderBy('<%= default_order %>', '<%= default_direction %>') : null;
      },
      { 
        ttl: '<%= all_ttl || ZERO_CONFIG.DEFAULT_TTL %>',
        defaultValue: []
      }
    );
  },

  /**
   * Find <%= table_name %> matching conditions (like Rails <%= class_name %>.where(...))
   * @param conditions - Object with field/value pairs to match
   * @returns ReactiveQuery with array of matching <%= table_name %>
   * 
   * @example
   * ```typescript
   * const active<%= class_name.pluralize %> = <%= class_name %>.where({ status: 'active' });
   * const recent<%= class_name.pluralize %> = <%= class_name %>.where({ created_at: '>2024-01-01' });
   * console.log(active<%= class_name.pluralize %>.records); // Filtered results
   * ```
   */
  where(conditions: Partial<<%= class_name %>>) {
    return QueryFactory.forCollection<<%= class_name %>>(
      () => {
        const zero = getZero();
        if (!zero) return null;
        
        let query = zero.query.<%= table_name %>;
        
        // Apply conditions (Rails-style where clauses)
        Object.entries(conditions).forEach(([key, value]) => {
          if (value !== undefined && value !== null) {
            query = query.where(key, value);
          }
        });
        
        return query
<% associations.each do |assoc| -%>
          .related('<%= assoc.name %>'<%= assoc.options %>)
<% end -%>
          .orderBy('<%= default_order %>', '<%= default_direction %>');
      },
      { 
        ttl: '<%= where_ttl || ZERO_CONFIG.DEFAULT_TTL %>',
        defaultValue: []
      }
    );
  },

<% scopes.each do |scope| -%>
  /**
   * <%= scope.description %> (Rails scope: <%= scope.name %>)
   * Generated from Rails model scope: <%= scope.rails_definition %>
   * 
   * @example
   * ```typescript
   * const scoped<%= class_name.pluralize %> = <%= class_name %>.<%= scope.name %>();
   * console.log(scoped<%= class_name.pluralize %>.records); // Scoped results
   * ```
   */
  <%= scope.name %>(<%= scope.parameters %>) {
    return QueryFactory.forCollection<<%= class_name %>>(
      () => {
        const zero = getZero();
        if (!zero) return null;
        
        let query = zero.query.<%= table_name %>;
        
        // Apply scope conditions (from Rails scope: <%= scope.rails_definition %>)
        <%= scope.zero_implementation %>
        
        return query
<% associations.each do |assoc| -%>
          .related('<%= assoc.name %>'<%= assoc.options %>)
<% end -%>
          .orderBy('<%= default_order %>', '<%= default_direction %>');
      },
      { 
        ttl: '<%= scope.ttl || ZERO_CONFIG.DEFAULT_TTL %>',
        defaultValue: []
      }
    );
  },

<% end -%>
  // Rails association methods

<% associations.each do |assoc| -%>
  /**
   * Find <%= table_name %> through association: <%= assoc.name %>
   * Generated from Rails association: <%= assoc.rails_definition %>
   * 
   * @param <%= assoc.foreign_key %> - The ID of the associated record
   * @returns ReactiveQuery with array of <%= table_name %>
   */
  <%= assoc.query_method_name %>(<%= assoc.foreign_key %>: string) {
    return QueryFactory.forCollection<<%= class_name %>>(
      () => {
        const zero = getZero();
        return zero ? zero.query.<%= table_name %>
          .where('<%= assoc.foreign_key %>', <%= assoc.foreign_key %>)
<% associations.each do |other_assoc| -%>
          .related('<%= other_assoc.name %>'<%= other_assoc.options %>)
<% end -%>
          .orderBy('<%= default_order %>', '<%= default_direction %>') : null;
      },
      { 
        ttl: '<%= assoc.ttl || ZERO_CONFIG.DEFAULT_TTL %>',
        defaultValue: []
      }
    );
  },

<% end -%>
};

// Export types for external use
export type { <%= class_name %>, Create<%= class_name %>Data, Update<%= class_name %>Data, <%= class_name %>MutationResult };

/*
 * üîÑ REGENERATION INFO:
 * 
 * This file was generated from:
 * - Rails model: app/models/<%= file_name %>.rb
 * - Generator template: <%= __FILE__ %>
 * - Generated at: <%= Time.current.iso8601 %>
 * - Generator version: <%= generator_version %>
 * 
 * Rails model information:
 * - Attributes: <%= attributes.count %>
 * - Associations: <%= associations.count %>
 * - Validations: <%= validations.count %>
 * - Scopes: <%= scopes.count %>
 * - Table: <%= table_name %>
 * 
 * üö´ DO NOT EDIT - Use `rails generate zero:mutations` to regenerate
 */