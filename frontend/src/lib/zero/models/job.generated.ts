// ü§ñ AUTO-GENERATED ZERO MUTATIONS
// Generated at: 2025-07-11T08:03:40Z
//
// ‚ö†Ô∏è  DO NOT EDIT THIS FILE DIRECTLY
// This file is automatically generated. Manual changes will be overwritten.
//
// üîß FOR CUSTOMIZATIONS:
// Use the corresponding .custom.ts file for your custom mutations
//
// üîÑ TO REGENERATE: Run `rails generate zero:mutations`


import { getZero } from '../zero-client';
import { ReactiveQuery, ReactiveQueryOne } from '../reactive-query.svelte';

// Generated TypeScript types for jobs
// TypeScript interfaces for jobs

/**
 * Complete Job record as stored in database
 */
export interface Job {
  title?: string| null;
  status?: number| null;
  priority?: number| null;
  created_at: number;
  updated_at: number;
  description?: string| null;
  lock_version: number;
  id: string;
  client_id?: string| null;
  created_by_id?: string| null;
  due_at?: number| null;
  due_time_set: boolean;
  starts_at?: number| null;
  start_time_set: boolean;
}

/**
 * Data required to create a new job
 * Excludes auto-generated fields (id, created_at, updated_at)
 */
export interface CreateJobData {
  title?: string| null;
  status?: number| null;
  priority?: number| null;
  description?: string| null;
  lock_version: number;
  client_id?: string| null;
  created_by_id?: string| null;
  due_at?: number| null;
  due_time_set: boolean;
  starts_at?: number| null;
  start_time_set: boolean;
}

/**
 * Data for updating an existing job
 * All fields optional, excludes auto-managed fields
 */
export interface UpdateJobData {
  title?: string| null;
  status?: number| null;
  priority?: number| null;
  description?: string| null;
  lock_version?: number;
  client_id?: string| null;
  created_by_id?: string| null;
  due_at?: number| null;
  due_time_set?: boolean;
  starts_at?: number| null;
  start_time_set?: boolean;
}

/**
 * Standard response from mutation operations
 */
export interface JobMutationResult {
  id: string;
}


// Generated CRUD mutations for jobs

/**
 * Create a new job
 * 
 * @param data - The job data to create
 * @returns Promise resolving to the created job ID
 * 
 * @example
 * ```typescript
 * import { createJob } from './job';
 * 
 * const result = await createJob({
 *   // Add required fields here based on your schema
 * });
 * console.log('Created job with ID:', result.id);
 * ```
 */
export async function createJob(data: CreateJobData): Promise<JobMutationResult> {
  const zero = getZero();
  
  // Validate required fields
  if (data.lock_version === undefined || data.lock_version === null) throw new Error('Lock version is required');
  if (data.due_time_set === undefined || data.due_time_set === null) throw new Error('Due time set is required');
  if (data.start_time_set === undefined || data.start_time_set === null) throw new Error('Start time set is required');
  // Generate unique ID with validation
  const id = crypto.randomUUID();
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Failed to generate valid UUID');
  }

  const now = Date.now();

  try {
    await zero.mutate.jobs.insert({
      id,
      ...data,
      created_at: now,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to create job: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Update an existing job
 * 
 * @param id - The UUID of the job to update
 * @param data - Partial job data for updates
 * @returns Promise resolving to the updated job ID
 * 
 * @example
 * ```typescript
 * import { updateJob } from './job';
 * 
 * const result = await updateJob('123e4567-e89b-12d3-a456-426614174000', {
 *   // Add fields to update
 * });
 * console.log('Updated job:', result.id);
 * ```
 */
export async function updateJob(id: string, data: UpdateJobData): Promise<JobMutationResult> {
  const zero = getZero();
  
  // Validate ID format
  if (!id || typeof id !== 'string') {
    throw new Error('Job ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Job ID must be a valid UUID');
  }

  // Validate that we have some data to update
  if (!data || Object.keys(data).length === 0) {
    throw new Error('Update data is required - at least one field must be provided');
  }

  const now = Date.now();

  try {
    await zero.mutate.jobs.update({
      id,
      ...data,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to update job: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Delete a job (permanent deletion)
 * 
 * @param id - The UUID of the job to delete
 * @returns Promise resolving to the deleted job ID
 * 
 * @example
 * ```typescript
 * import { deleteJob } from './job';
 * 
 * const result = await deleteJob('123e4567-e89b-12d3-a456-426614174000');
 * console.log('Deleted job:', result.id);
 * ```
 * 
 * @warning This is a permanent deletion and cannot be undone
 */
export async function deleteJob(id: string): Promise<JobMutationResult> {
  const zero = getZero();
  
  // Validate ID format
  if (!id || typeof id !== 'string') {
    throw new Error('Job ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Job ID must be a valid UUID');
  }

  try {
    await zero.mutate.jobs.delete({
      id
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to delete job: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Create or update a job (upsert operation)
 * 
 * @param data - The job data with optional ID for update, without ID for create
 * @returns Promise resolving to the job ID (generated if creating, provided if updating)
 * 
 * @example
 * ```typescript
 * import { upsertJob } from './job';
 * 
 * // Create new job (no ID provided)
 * const newResult = await upsertJob({
 *   // Add required fields here
 * });
 * 
 * // Update existing job (ID provided)
 * const updateResult = await upsertJob({
 *   id: '123e4567-e89b-12d3-a456-426614174000',
 *   // Add fields to update
 * });
 * ```
 */
export async function upsertJob(data: (CreateJobData & { id?: string }) | (UpdateJobData & { id: string })): Promise<JobMutationResult> {
  const zero = getZero();
  
  // Validate data is provided
  if (!data || Object.keys(data).length === 0) {
    throw new Error('Upsert data is required');
  }

  let id: string;
  const now = Date.now();

  // If ID is provided, validate it for update operation
  if (data.id) {
    if (!data.id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
      throw new Error('Job ID must be a valid UUID');
    }
    id = data.id;
  } else {
    // Generate new ID for create operation
    id = crypto.randomUUID();
    if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
      throw new Error('Failed to generate valid UUID');
    }
  }

  try {
    await zero.mutate.jobs.upsert({
      ...data,
      id,
      updated_at: now,
      // Set created_at only if this is a new record
      ...(data.id ? {} : { created_at: now }),
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to upsert job: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


// Generated ActiveRecord-style queries for jobs
// Uses new ReactiveQuery classes with Zero's native addListener for real-time updates

/**
 * ActiveRecord-style query interface for jobs
 * Provides offline-capable queries that work with Zero's local database
 */
export const Job = {
  /**
   * Find a single job by ID
   * @param id - The UUID of the job
   * @returns Reactive query with the job or null
   * 
   * @example
   * ```typescript
   * // In Svelte component
   * const job = Job.find('123e4567-e89b-12d3-a456-426614174000');
   * // job.data is reactive
   * 
   * // In vanilla JS
   * const job = Job.find('123e4567-e89b-12d3-a456-426614174000');
   * console.log(job.current); // Current job data
   * job.subscribe((data) => console.log('Job updated:', data));
   * ```
   */
  find(id: string) {
    return new ReactiveQueryOne<Job>(
      () => {
        const zero = getZero();
        return zero ? zero.query.jobs.where('id', id).one() : null;
      },
      null
    );
  },

  /**
   * Get all jobs
   * @returns Reactive query with array of jobs
   * 
   * @example
   * ```typescript
   * // In Svelte component
   * const allJobs = Job.all();
   * // allJobs.data is reactive array
   * 
   * // In vanilla JS
   * const allJobs = Job.all();
   * console.log(allJobs.current); // Current jobs array
   * allJobs.subscribe((data) => console.log('Jobs updated:', data.length));
   * ```
   */
  all() {
    return new ReactiveQuery<Job>(
      () => {
        const zero = getZero();
        return zero ? zero.query.jobs.orderBy('created_at', 'desc') : null;
      },
      []
    );
  },

  /**
   * Find jobs matching conditions
   * @param conditions - Object with field/value pairs to match
   * @returns Reactive query with array of matching jobs
   * 
   * @example
   * ```typescript
   * // In Svelte component
   * const activeJobs = Job.where({ status: 1 }); // reactive array
   * const clientJobs = Job.where({ client_id: 'some-uuid' });
   * 
   * // In vanilla JS
   * const activeJobs = Job.where({ status: 1 });
   * console.log(activeJobs.current); // Current matching jobs
   * activeJobs.subscribe((data) => console.log('Active jobs:', data.length));
   * ```
   */
  where(conditions: Partial<Job>) {
    return new ReactiveQuery<Job>(
      () => {
        const zero = getZero();
        if (!zero) return null;
        
        let query = zero.query.jobs;
        
        Object.entries(conditions).forEach(([key, value]) => {
          if (value !== undefined && value !== null) {
            query = query.where(key, value);
          }
        });
        
        return query.orderBy('created_at', 'desc');
      },
      []
    );
  }
};

