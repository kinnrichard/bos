// ü§ñ AUTO-GENERATED ZERO MUTATIONS
// Generated at: 2025-07-11T06:54:06Z
//
// ‚ö†Ô∏è  DO NOT EDIT THIS FILE DIRECTLY
// This file is automatically generated. Manual changes will be overwritten.
//
// üîß FOR CUSTOMIZATIONS:
// Use the corresponding .custom.ts file for your custom mutations
//
// üîÑ TO REGENERATE: Run `rails generate zero:mutations`


import { getZero } from './client';

// Generated TypeScript types for tasks
// TypeScript interfaces for tasks

/**
 * Complete Task record as stored in database
 */
export interface Task {
  title?: string| null;
  status?: number| null;
  position?: number| null;
  created_at: number;
  updated_at: number;
  subtasks_count?: number| null;
  reordered_at?: number| null;
  lock_version: number;
  applies_to_all_targets: boolean;
  id: string;
  job_id?: string| null;
  assigned_to_id?: string| null;
  parent_id?: string| null;
  deleted_at?: number| null;
}

/**
 * Data required to create a new task
 * Excludes auto-generated fields (id, created_at, updated_at)
 */
export interface CreateTaskData {
  title?: string| null;
  status?: number| null;
  position?: number; // Auto-calculated if not provided
  subtasks_count?: number| null;
  reordered_at?: number| null;
  lock_version: number;
  applies_to_all_targets: boolean;
  job_id?: string| null;
  assigned_to_id?: string| null;
  parent_id?: string| null;
}

/**
 * Data for updating an existing task
 * All fields optional, excludes auto-managed fields
 */
export interface UpdateTaskData {
  title?: string| null;
  status?: number| null;
  position?: number| null;
  subtasks_count?: number| null;
  reordered_at?: number| null;
  lock_version?: number;
  applies_to_all_targets?: boolean;
  job_id?: string| null;
  assigned_to_id?: string| null;
  parent_id?: string| null;
  deleted_at?: number| null;
}

/**
 * Standard response from mutation operations
 */
export interface TaskMutationResult {
  id: string;
}


// Generated CRUD mutations for tasks

/**
 * Create a new task
 * 
 * @param data - The task data to create
 * @returns Promise resolving to the created task ID
 * 
 * @example
 * ```typescript
 * import { createTask } from './task';
 * 
 * const result = await createTask({
 *   // Add required fields here based on your schema
 * });
 * console.log('Created task with ID:', result.id);
 * ```
 */
export async function createTask(data: CreateTaskData): Promise<TaskMutationResult> {
  const zero = getZero();
  
  // Validate required fields
  if (data.lock_version === undefined || data.lock_version === null) throw new Error('Lock version is required');
  if (data.applies_to_all_targets === undefined || data.applies_to_all_targets === null) throw new Error('Applies to all targets is required');
  // Generate unique ID with validation
  const id = crypto.randomUUID();
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Failed to generate valid UUID');
  }

  const now = Date.now();

  try {
    await zero.mutate.tasks.insert({
      id,
      ...data,
      created_at: now,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to create task: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Update an existing task
 * 
 * @param id - The UUID of the task to update
 * @param data - Partial task data for updates
 * @returns Promise resolving to the updated task ID
 * 
 * @example
 * ```typescript
 * import { updateTask } from './task';
 * 
 * const result = await updateTask('123e4567-e89b-12d3-a456-426614174000', {
 *   // Add fields to update
 * });
 * console.log('Updated task:', result.id);
 * ```
 */
export async function updateTask(id: string, data: UpdateTaskData): Promise<TaskMutationResult> {
  const zero = getZero();
  
  // Validate ID format
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }

  // Validate that we have some data to update
  if (!data || Object.keys(data).length === 0) {
    throw new Error('Update data is required - at least one field must be provided');
  }

  const now = Date.now();

  try {
    await zero.mutate.tasks.update({
      id,
      ...data,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to update task: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Delete a task (soft deletion)
 * 
 * @param id - The UUID of the task to delete
 * @returns Promise resolving to the deleted task ID
 * 
 * @example
 * ```typescript
 * import { deleteTask } from './task';
 * 
 * const result = await deleteTask('123e4567-e89b-12d3-a456-426614174000');
 * console.log('Deleted task:', result.id);
 * ```
 */
export async function deleteTask(id: string): Promise<TaskMutationResult> {
  const zero = getZero();
  
  // Validate ID format
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }

  const now = Date.now();

  try {
    await zero.mutate.tasks.update({
      id,
      deleted_at: now,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to delete task: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Create or update a task (upsert operation)
 * 
 * @param data - The task data with optional ID for update, without ID for create
 * @returns Promise resolving to the task ID (generated if creating, provided if updating)
 * 
 * @example
 * ```typescript
 * import { upsertTask } from './task';
 * 
 * // Create new task (no ID provided)
 * const newResult = await upsertTask({
 *   // Add required fields here
 * });
 * 
 * // Update existing task (ID provided)
 * const updateResult = await upsertTask({
 *   id: '123e4567-e89b-12d3-a456-426614174000',
 *   // Add fields to update
 * });
 * ```
 */
export async function upsertTask(data: (CreateTaskData & { id?: string }) | (UpdateTaskData & { id: string })): Promise<TaskMutationResult> {
  const zero = getZero();
  
  // Validate data is provided
  if (!data || Object.keys(data).length === 0) {
    throw new Error('Upsert data is required');
  }

  let id: string;
  const now = Date.now();

  // If ID is provided, validate it for update operation
  if (data.id) {
    if (!data.id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
      throw new Error('Task ID must be a valid UUID');
    }
    id = data.id;
  } else {
    // Generate new ID for create operation
    id = crypto.randomUUID();
    if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
      throw new Error('Failed to generate valid UUID');
    }
  }

  try {
    await zero.mutate.tasks.upsert({
      ...data,
      id,
      updated_at: now,
      // Set created_at only if this is a new record
      ...(data.id ? {} : { created_at: now }),
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to upsert task: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Move task before another task in the position order
 * 
 * @param id - The UUID of the task to move
 * @param targetId - The UUID of the task to move before
 * @returns Promise resolving to the moved task ID
 * 
 * @example
 * ```typescript
 * import { moveBeforeTask } from './task';
 * 
 * const result = await moveBeforeTask(
 *   '123e4567-e89b-12d3-a456-426614174000',
 *   '987fcdeb-51d3-12b3-c456-987654321000'
 * );
 * ```
 */
export async function moveBeforeTask(id: string, targetId: string): Promise<TaskMutationResult> {
  const zero = getZero();
  
  // Validate IDs
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  if (!targetId || typeof targetId !== 'string') {
    throw new Error('Target Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }
  if (!targetId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Target Task ID must be a valid UUID');
  }
  
  const now = Date.now();
  
  try {
    // TODO: Implementation should calculate new position based on target
    // This is a placeholder - full implementation needed
    await zero.mutate.tasks.update({
      id,
      // position: calculated_position,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to move task before target: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Move task after another task in the position order
 * 
 * @param id - The UUID of the task to move
 * @param targetId - The UUID of the task to move after
 * @returns Promise resolving to the moved task ID
 * 
 * @example
 * ```typescript
 * import { moveAfterTask } from './task';
 * 
 * const result = await moveAfterTask(
 *   '123e4567-e89b-12d3-a456-426614174000',
 *   '987fcdeb-51d3-12b3-c456-987654321000'
 * );
 * ```
 */
export async function moveAfterTask(id: string, targetId: string): Promise<TaskMutationResult> {
  const zero = getZero();
  
  // Validate IDs
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  if (!targetId || typeof targetId !== 'string') {
    throw new Error('Target Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }
  if (!targetId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Target Task ID must be a valid UUID');
  }
  
  const now = Date.now();
  
  try {
    // TODO: Implementation should calculate new position based on target
    // This is a placeholder - full implementation needed
    await zero.mutate.tasks.update({
      id,
      // position: calculated_position,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to move task after target: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Move task to the first position (position 0)
 * 
 * @param id - The UUID of the task to move to top
 * @returns Promise resolving to the moved task ID
 * 
 * @example
 * ```typescript
 * import { moveToTopTask } from './task';
 * 
 * const result = await moveToTopTask('123e4567-e89b-12d3-a456-426614174000');
 * console.log('Moved task to top:', result.id);
 * ```
 */
export async function moveToTopTask(id: string): Promise<TaskMutationResult> {
  const zero = getZero();
  
  // Validate ID
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }
  
  const now = Date.now();
  
  try {
    await zero.mutate.tasks.update({
      id,
      position: 0,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to move task to top: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Move task to the last position
 * 
 * @param id - The UUID of the task to move to bottom
 * @returns Promise resolving to the moved task ID
 * 
 * @example
 * ```typescript
 * import { moveToBottomTask } from './task';
 * 
 * const result = await moveToBottomTask('123e4567-e89b-12d3-a456-426614174000');
 * console.log('Moved task to bottom:', result.id);
 * ```
 */
export async function moveToBottomTask(id: string): Promise<TaskMutationResult> {
  const zero = getZero();
  
  // Validate ID
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }
  
  const now = Date.now();
  
  try {
    // TODO: Implementation should query for max position and set position accordingly
    // This is a placeholder - full implementation needed
    await zero.mutate.tasks.update({
      id,
      // position: max_position + 1,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to move task to bottom: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Restore a soft-deleted task
 * 
 * @param id - The UUID of the task to restore
 * @returns Promise resolving to the restored task ID
 * 
 * @example
 * ```typescript
 * import { restoreTask } from './task';
 * 
 * const result = await restoreTask('123e4567-e89b-12d3-a456-426614174000');
 * console.log('Restored task:', result.id);
 * ```
 */
export async function restoreTask(id: string): Promise<TaskMutationResult> {
  const zero = getZero();
  
  // Validate ID format
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }

  const now = Date.now();

  try {
    await zero.mutate.tasks.update({
      id,
      deleted_at: null,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to restore task: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

