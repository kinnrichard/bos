// ü§ñ AUTO-GENERATED ZERO MUTATIONS
// Generated at: 2025-07-14T01:59:17Z
//
// ‚ö†Ô∏è  DO NOT EDIT THIS FILE DIRECTLY
// This file is automatically generated. Manual changes will be overwritten.
//
// üîß FOR CUSTOMIZATIONS:
// Use the corresponding .custom.ts file for your custom mutations
//
// üîÑ TO REGENERATE: Run `rails generate zero:mutations`


import { getZero } from './zero-client';
import { RecordInstance, type ZeroMutations } from '../record-factory/record-instance';

// Generated TypeScript types for tasks
// TypeScript interfaces for tasks

/**
 * Complete Task record as stored in database
 */
export interface Task {
  title?: string| null;
  status?: 0 | 1 | 2 | 3 | 4| null;
  position?: number| null;
  created_at: number;
  updated_at: number;
  subtasks_count?: number| null;
  reordered_at?: number| null;
  lock_version: number;
  applies_to_all_targets: boolean;
  id: string;
  job_id?: string| null;
  assigned_to_id?: string| null;
  parent_id?: string| null;
  discarded_at?: number| null;
}

/**
 * Data required to create a new task
 * Excludes auto-generated fields (id, created_at, updated_at)
 */
export interface CreateTaskData {
  title?: string| null;
  status?: 0 | 1 | 2 | 3 | 4| null;
  position?: number; // Auto-calculated if not provided
  subtasks_count?: number| null;
  reordered_at?: number| null;
  lock_version: number;
  applies_to_all_targets: boolean;
  job_id?: string| null;
  assigned_to_id?: string| null;
  parent_id?: string| null;
}

/**
 * Data for updating an existing task
 * All fields optional, excludes auto-managed fields
 */
export interface UpdateTaskData {
  title?: string| null;
  status?: 0 | 1 | 2 | 3 | 4| null;
  position?: number| null;
  subtasks_count?: number| null;
  reordered_at?: number| null;
  lock_version?: number;
  applies_to_all_targets?: boolean;
  job_id?: string| null;
  assigned_to_id?: string| null;
  parent_id?: string| null;
  discarded_at?: number| null;
}

/**
 * Standard response from mutation operations
 */
export interface TaskMutationResult {
  id: string;
}


// Generated CRUD mutations for tasks

/**
 * Create a new task
 * 
 * @param data - The task data to create
 * @returns Promise resolving to the created task ID
 * 
 * @example
 * ```typescript
 * import { createTask } from './task';
 * 
 * const result = await createTask({
 *   // Add required fields here based on your schema
 * });
 * console.log('Created task with ID:', result.id);
 * ```
 */
export async function createTask(data: CreateTaskData): Promise<TaskMutationResult> {
  const zero = getZero();
  if (!zero) {
    throw new Error('Zero client not initialized. Please ensure Zero is properly set up.');
  }
  
  // Validate required fields
  if (data.lock_version === undefined || data.lock_version === null) throw new Error('Lock version is required');
  if (data.applies_to_all_targets === undefined || data.applies_to_all_targets === null) throw new Error('Applies to all targets is required');
  // Generate unique ID with validation
  const id = crypto.randomUUID();
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Failed to generate valid UUID');
  }

  const now = Date.now();

  try {
    await zero.mutate.tasks.insert({
      id,
      ...data,
      created_at: now,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to create task: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Update an existing task
 * 
 * @param id - The UUID of the task to update
 * @param data - Partial task data for updates
 * @returns Promise resolving to the updated task ID
 * 
 * @example
 * ```typescript
 * import { updateTask } from './task';
 * 
 * const result = await updateTask('123e4567-e89b-12d3-a456-426614174000', {
 *   // Add fields to update
 * });
 * console.log('Updated task:', result.id);
 * ```
 */
export async function updateTask(id: string, data: UpdateTaskData): Promise<TaskMutationResult> {
  const zero = getZero();
  if (!zero) {
    throw new Error('Zero client not initialized. Please ensure Zero is properly set up.');
  }
  
  // Validate ID format
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }

  // Validate that we have some data to update
  if (!data || Object.keys(data).length === 0) {
    throw new Error('Update data is required - at least one field must be provided');
  }

  const now = Date.now();

  try {
    await zero.mutate.tasks.update({
      id,
      ...data,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to update task: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Discard a task (soft deletion using discard gem)
 * 
 * @param id - The UUID of the task to discard
 * @returns Promise resolving to the discarded task ID
 * 
 * @example
 * ```typescript
 * import { discardTask } from './task';
 * 
 * const result = await discardTask('123e4567-e89b-12d3-a456-426614174000');
 * console.log('Discarded task:', result.id);
 * ```
 */
export async function discardTask(id: string): Promise<TaskMutationResult> {
  const zero = getZero();
  if (!zero) {
    throw new Error('Zero client not initialized. Please ensure Zero is properly set up.');
  }
  
  // Validate ID format
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }

  const now = Date.now();

  try {
    await zero.mutate.tasks.update({
      id,
      discarded_at: now,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to discard task: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Create or update a task (upsert operation)
 * 
 * @param data - The task data with optional ID for update, without ID for create
 * @returns Promise resolving to the task ID (generated if creating, provided if updating)
 * 
 * @example
 * ```typescript
 * import { upsertTask } from './task';
 * 
 * // Create new task (no ID provided)
 * const newResult = await upsertTask({
 *   // Add required fields here
 * });
 * 
 * // Update existing task (ID provided)
 * const updateResult = await upsertTask({
 *   id: '123e4567-e89b-12d3-a456-426614174000',
 *   // Add fields to update
 * });
 * ```
 */
export async function upsertTask(data: (CreateTaskData & { id?: string }) | (UpdateTaskData & { id: string })): Promise<TaskMutationResult> {
  const zero = getZero();
  if (!zero) {
    throw new Error('Zero client not initialized. Please ensure Zero is properly set up.');
  }
  
  // Validate data is provided
  if (!data || Object.keys(data).length === 0) {
    throw new Error('Upsert data is required');
  }

  let id: string;
  const now = Date.now();

  // If ID is provided, validate it for update operation
  if (data.id) {
    if (!data.id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
      throw new Error('Task ID must be a valid UUID');
    }
    id = data.id;
  } else {
    // Generate new ID for create operation
    id = crypto.randomUUID();
    if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
      throw new Error('Failed to generate valid UUID');
    }
  }

  try {
    const upsertData: any = {
      ...data,
      id,
      updated_at: now,
    };
    
    // Set created_at only if this is a new record
    if (!data.id) {
      upsertData.created_at = now;
    }
    
    await zero.mutate.tasks.upsert(upsertData);

    return { id };
  } catch (error) {
    throw new Error(`Failed to upsert task: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Move task before another task in the position order
 * 
 * @param id - The UUID of the task to move
 * @param targetId - The UUID of the task to move before
 * @returns Promise resolving to the moved task ID
 * 
 * @example
 * ```typescript
 * import { moveBeforeTask } from './task';
 * 
 * const result = await moveBeforeTask(
 *   '123e4567-e89b-12d3-a456-426614174000',
 *   '987fcdeb-51d3-12b3-c456-987654321000'
 * );
 * ```
 */
export async function moveBeforeTask(id: string, targetId: string): Promise<TaskMutationResult> {
  const zero = getZero();
  if (!zero) {
    throw new Error('Zero client not initialized. Please ensure Zero is properly set up.');
  }
  
  // Validate IDs
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  if (!targetId || typeof targetId !== 'string') {
    throw new Error('Target Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }
  if (!targetId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Target Task ID must be a valid UUID');
  }
  
  const now = Date.now();
  
  try {
    // Get all records in the same scope to calculate position
    const view = zero.query.tasks.materialize();
    const allRecords = await view.data;
    const targetRecord = Array.isArray(allRecords) ? 
      allRecords.find(record => record.id === targetId) : 
      (allRecords && allRecords.id === targetId ? allRecords : null);
    view.destroy();
    
    if (!targetRecord) {
      throw new Error('Target task not found');
    }
    
    // Calculate position to insert before target (target.position)
    const newPosition = targetRecord.position || 1;
    
    await zero.mutate.tasks.update({
      id,
      position: newPosition,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to move task before target: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Move task after another task in the position order
 * 
 * @param id - The UUID of the task to move
 * @param targetId - The UUID of the task to move after
 * @returns Promise resolving to the moved task ID
 * 
 * @example
 * ```typescript
 * import { moveAfterTask } from './task';
 * 
 * const result = await moveAfterTask(
 *   '123e4567-e89b-12d3-a456-426614174000',
 *   '987fcdeb-51d3-12b3-c456-987654321000'
 * );
 * ```
 */
export async function moveAfterTask(id: string, targetId: string): Promise<TaskMutationResult> {
  const zero = getZero();
  if (!zero) {
    throw new Error('Zero client not initialized. Please ensure Zero is properly set up.');
  }
  
  // Validate IDs
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  if (!targetId || typeof targetId !== 'string') {
    throw new Error('Target Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }
  if (!targetId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Target Task ID must be a valid UUID');
  }
  
  const now = Date.now();
  
  try {
    // Get all records in the same scope to calculate position
    const view = zero.query.tasks.materialize();
    const allRecords = await view.data;
    const targetRecord = Array.isArray(allRecords) ? 
      allRecords.find(record => record.id === targetId) : 
      (allRecords && allRecords.id === targetId ? allRecords : null);
    view.destroy();
    
    if (!targetRecord) {
      throw new Error('Target task not found');
    }
    
    // Calculate position to insert after target (target.position + 1)
    const newPosition = (targetRecord.position || 0) + 1;
    
    await zero.mutate.tasks.update({
      id,
      position: newPosition,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to move task after target: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Move task to the first position (position 0)
 * 
 * @param id - The UUID of the task to move to top
 * @returns Promise resolving to the moved task ID
 * 
 * @example
 * ```typescript
 * import { moveToTopTask } from './task';
 * 
 * const result = await moveToTopTask('123e4567-e89b-12d3-a456-426614174000');
 * console.log('Moved task to top:', result.id);
 * ```
 */
export async function moveToTopTask(id: string): Promise<TaskMutationResult> {
  const zero = getZero();
  if (!zero) {
    throw new Error('Zero client not initialized. Please ensure Zero is properly set up.');
  }
  
  // Validate ID
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }
  
  const now = Date.now();
  
  try {
    // Move to position 1 (first position)
    await zero.mutate.tasks.update({
      id,
      position: 1,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to move task to top: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Move task to the last position
 * 
 * @param id - The UUID of the task to move to bottom
 * @returns Promise resolving to the moved task ID
 * 
 * @example
 * ```typescript
 * import { moveToBottomTask } from './task';
 * 
 * const result = await moveToBottomTask('123e4567-e89b-12d3-a456-426614174000');
 * console.log('Moved task to bottom:', result.id);
 * ```
 */
export async function moveToBottomTask(id: string): Promise<TaskMutationResult> {
  const zero = getZero();
  if (!zero) {
    throw new Error('Zero client not initialized. Please ensure Zero is properly set up.');
  }
  
  // Validate ID
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }
  
  const now = Date.now();
  
  try {
    // Get all records to find the maximum position
    const view = zero.query.tasks.materialize();
    const allRecords = await view.data;
    const recordsArray = Array.isArray(allRecords) ? allRecords : (allRecords ? [allRecords] : []);
    const maxPosition = Math.max(...recordsArray.map(r => r.position || 0), 0);
    view.destroy();
    
    await zero.mutate.tasks.update({
      id,
      position: maxPosition + 1,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to move task to bottom: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Undiscard a discarded task (restore using discard gem)
 * 
 * @param id - The UUID of the task to undiscard
 * @returns Promise resolving to the undiscarded task ID
 * 
 * @example
 * ```typescript
 * import { undiscardTask } from './task';
 * 
 * const result = await undiscardTask('123e4567-e89b-12d3-a456-426614174000');
 * console.log('Undiscarded task:', result.id);
 * ```
 */
export async function undiscardTask(id: string): Promise<TaskMutationResult> {
  const zero = getZero();
  if (!zero) {
    throw new Error('Zero client not initialized. Please ensure Zero is properly set up.');
  }
  
  // Validate ID format
  if (!id || typeof id !== 'string') {
    throw new Error('Task ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Task ID must be a valid UUID');
  }

  const now = Date.now();

  try {
    await zero.mutate.tasks.update({
      id,
      discarded_at: null,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to undiscard task: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}



// ActiveRecord-style instance class for individual task records

/**
 * ActiveRecord-style instance class for Task
 * Provides Rails-compatible instance methods: update(), delete(), restore()
 * 
 * Generated from Rails model: Task
 * 
 * @example
 * ```typescript
 * const task = Task.find('123').current;
 * if (task) {
 *   const instance = new TaskInstance(task);
 *   await instance.update({ title: 'Updated Title', status: new_task });
 *   await instance.delete(); // Soft delete
 *   await instance.restore(); // Restore from soft delete
 * }
 * ```
 */
export class TaskInstance extends RecordInstance<Task> {
  protected mutations: ZeroMutations<Task> = {
    update: async (id: string, data: Partial<Task>) => {
      return await updateTask(id, data as UpdateTaskData);
    },
    delete: async (id: string) => {
      return await discardTask(id);
    },
            undiscard: async (id: string) => {
              return await undiscardTask(id);
            }
  };

  constructor(data: Task) {
    super(data);
  }

/**
 * Check if this record is discarded
 * Rails discard gem pattern: checks for discarded_at timestamp
 */
get isDiscarded(): boolean {
  return !!(this.data as any).discarded_at;
}

/**
 * Check if this record is kept (not discarded)
 * Rails discard gem pattern: opposite of discarded
 */
get isKept(): boolean {
  return !(this.data as any).discarded_at;
}


/**
 * Move this record before another record
 * Rails acts_as_list pattern
 */
async moveBefore(targetTaskId: string): Promise<{ id: string }> {
  return await moveBeforeTask(this.data.id, targetTaskId);
}

/**
 * Move this record after another record
 * Rails acts_as_list pattern
 */
async moveAfter(targetTaskId: string): Promise<{ id: string }> {
  return await moveAfterTask(this.data.id, targetTaskId);
}

/**
 * Move this record to the top of the list
 * Rails acts_as_list pattern
 */
async moveToTop(): Promise<{ id: string }> {
  return await moveToTopTask(this.data.id);
}

/**
 * Move this record to the bottom of the list
 * Rails acts_as_list pattern
 */
async moveToBottom(): Promise<{ id: string }> {
  return await moveToBottomTask(this.data.id);
}


/**
 * Convenience method for updating status
 * Generated from Rails enum
 */
async updateStatus(status: string): Promise<{ id: string }> {
  return await this.update({ status: status as any });
}



  /**
   * Rails-compatible inspect method for debugging
   */
  inspect(): string {
    return `#<TaskInstance id: ${this.data.id}, title: "${(this.data as any).title}">`;
  }
}

/**
 * Factory function to create TaskInstance from data
 * Used internally by ReactiveRecord and ActiveRecord
 */
export function createTaskInstance(data: Task): TaskInstance {
  return new TaskInstance(data);
}


// Generated ActiveRecord-style queries for tasks


// Zero reactive query wrapper using materialize() for active queries
// This creates active queries that populate Zero's cache and stay synchronized
function createReactiveQuery<T>(queryBuilder: any, defaultValue: T) {
  let current = defaultValue;
  let resultType: 'loading' | 'success' | 'error' = 'loading';
  let error: Error | null = null;
  let view: any = null;
  let retryCount = 0;
  const maxRetries = 3;

  const execute = async () => {
    try {
      resultType = 'loading';
      
      // Check if Zero is ready
      const zero = getZero();
      if (!zero) {
        setTimeout(() => execute(), 100);
        return;
      }
      
      // Create active query using materialize()
      view = queryBuilder.materialize();
      const result = await view.data;
      
      // If result is null and we haven't retried much, try again
      if ((result === null || result === undefined) && retryCount < maxRetries) {
        retryCount++;
        setTimeout(() => execute(), 500);
        return;
      }
      
      current = result || defaultValue;
      resultType = 'success';
      error = null;
      retryCount = 0;
    } catch (err) {
      error = err instanceof Error ? err : new Error('Unknown error');
      resultType = 'error';
      
      // Retry on error if we haven't exceeded max retries
      if (retryCount < maxRetries) {
        retryCount++;
        setTimeout(() => execute(), 1000);
      }
    }
  };

  // Execute after a small delay to let Zero initialize
  setTimeout(() => execute(), 100);

  return {
    get current() { return current; },
    get value() { return current; },
    get resultType() { return resultType; },
    get error() { return error; },
    refresh: execute,
    destroy: () => view?.destroy()
  };
}

/**
 * ActiveRecord-style query interface for tasks
 * Provides offline-capable queries that work with Zero's local database
 */
export const Task = {
  /**
   * Find a single task by ID
   * @param id - The UUID of the task
   * @returns Zero query result with the task or null
   * 
   * @example
   * ```typescript
   * const task = Task.find('123e4567-e89b-12d3-a456-426614174000');
   * console.log(task.current); // The task object or null
   * ```
   */
  find(id: string) {
    const zero = getZero();
    if (!zero) return { current: null, value: null, resultType: 'loading' as const, error: null };
    
    return createReactiveQuery(
      zero.query.tasks.where('id', id).one(),
      null as Task | null
    );
  },

  /**
   * Get all tasks (includes discarded records like Rails Task.all)
   * @returns Zero query result with array of tasks
   * 
   * @example
   * ```typescript
   * const allTasks = Task.all();
   * console.log(allTasks.current); // Array of tasks including discarded
   * ```
   */
  all() {
    const zero = getZero();
    if (!zero) return { current: [], value: [], resultType: 'loading' as const, error: null };
    
    return createReactiveQuery(
      zero.query.tasks.orderBy('created_at', 'desc'),
      [] as Task[]
    );
  },

  /**
   * Find tasks matching conditions (includes discarded)
   * @param conditions - Object with field/value pairs to match
   * @returns Zero query result with array of matching tasks
   * 
   * @example
   * ```typescript
   * const activeTasks = Task.where({ status: 'active' });
   * const clientJobs = Task.where({ client_id: 'some-uuid' });
   * ```
   */
  where(conditions: Partial<Task>) {
    const zero = getZero();
    if (!zero) return { current: [], value: [], resultType: 'loading' as const, error: null };
    
    let query = zero.query.tasks;
    
    Object.entries(conditions).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        query = query.where(key as any, value);
      }
    });
    
    return createReactiveQuery(
      query.orderBy('created_at', 'desc'),
      [] as Task[]
    );
  }  ,

  /**
   * Get only kept (non-discarded) tasks - like Rails Task.kept
   * @returns Zero query result with array of kept tasks
   */
  kept() {
    const zero = getZero();
    if (!zero) return { current: [], value: [], resultType: 'loading' as const, error: null };
    
    return createReactiveQuery(
      zero.query.tasks.where('discarded_at', 'IS', null).orderBy('created_at', 'desc'),
      [] as Task[]
    );
  },

  /**
   * Get only discarded tasks - like Rails Task.discarded
   * @returns Zero query result with array of discarded tasks
   */
  discarded() {
    const zero = getZero();
    if (!zero) return { current: [], value: [], resultType: 'loading' as const, error: null };
    
    return createReactiveQuery(
      zero.query.tasks.where('discarded_at', 'IS NOT', null).orderBy('created_at', 'desc'),
      [] as Task[]
    );
  }

};

