// ü§ñ AUTO-GENERATED ZERO MUTATIONS
// Generated at: 2025-07-13T05:31:50Z
//
// ‚ö†Ô∏è  DO NOT EDIT THIS FILE DIRECTLY
// This file is automatically generated. Manual changes will be overwritten.
//
// üîß FOR CUSTOMIZATIONS:
// Use the corresponding .custom.ts file for your custom mutations
//
// üîÑ TO REGENERATE: Run `rails generate zero:mutations`


import { getZero } from './zero-client';

// Generated TypeScript types for users
// TypeScript interfaces for users

/**
 * Complete User record as stored in database
 */
export interface User {
  name?: string| null;
  email?: string| null;
  role?: 0 | 1 | 2 | 3| null;
  created_at: number;
  updated_at: number;
  password_digest?: string| null;
  resort_tasks_on_status_change: boolean;
  id: string;
}

/**
 * Data required to create a new user
 * Excludes auto-generated fields (id, created_at, updated_at)
 */
export interface CreateUserData {
  name?: string| null;
  email?: string| null;
  role?: 0 | 1 | 2 | 3| null;
  password_digest?: string| null;
  resort_tasks_on_status_change: boolean;
}

/**
 * Data for updating an existing user
 * All fields optional, excludes auto-managed fields
 */
export interface UpdateUserData {
  name?: string| null;
  email?: string| null;
  role?: 0 | 1 | 2 | 3| null;
  password_digest?: string| null;
  resort_tasks_on_status_change?: boolean;
}

/**
 * Standard response from mutation operations
 */
export interface UserMutationResult {
  id: string;
}


// Generated CRUD mutations for users

/**
 * Create a new user
 * 
 * @param data - The user data to create
 * @returns Promise resolving to the created user ID
 * 
 * @example
 * ```typescript
 * import { createUser } from './user';
 * 
 * const result = await createUser({
 *   // Add required fields here based on your schema
 * });
 * console.log('Created user with ID:', result.id);
 * ```
 */
export async function createUser(data: CreateUserData): Promise<UserMutationResult> {
  const zero = getZero();
  
  // Validate required fields
  if (data.resort_tasks_on_status_change === undefined || data.resort_tasks_on_status_change === null) throw new Error('Resort tasks on status change is required');
  // Generate unique ID with validation
  const id = crypto.randomUUID();
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('Failed to generate valid UUID');
  }

  const now = Date.now();

  try {
    await zero.mutate.users.insert({
      id,
      ...data,
      created_at: now,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to create user: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Update an existing user
 * 
 * @param id - The UUID of the user to update
 * @param data - Partial user data for updates
 * @returns Promise resolving to the updated user ID
 * 
 * @example
 * ```typescript
 * import { updateUser } from './user';
 * 
 * const result = await updateUser('123e4567-e89b-12d3-a456-426614174000', {
 *   // Add fields to update
 * });
 * console.log('Updated user:', result.id);
 * ```
 */
export async function updateUser(id: string, data: UpdateUserData): Promise<UserMutationResult> {
  const zero = getZero();
  
  // Validate ID format
  if (!id || typeof id !== 'string') {
    throw new Error('User ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('User ID must be a valid UUID');
  }

  // Validate that we have some data to update
  if (!data || Object.keys(data).length === 0) {
    throw new Error('Update data is required - at least one field must be provided');
  }

  const now = Date.now();

  try {
    await zero.mutate.users.update({
      id,
      ...data,
      updated_at: now,
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to update user: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Delete a user (permanent deletion)
 * 
 * @param id - The UUID of the user to delete
 * @returns Promise resolving to the deleted user ID
 * 
 * @example
 * ```typescript
 * import { deleteUser } from './user';
 * 
 * const result = await deleteUser('123e4567-e89b-12d3-a456-426614174000');
 * console.log('Deleted user:', result.id);
 * ```
 * 
 * @warning This is a permanent deletion and cannot be undone
 */
export async function deleteUser(id: string): Promise<UserMutationResult> {
  const zero = getZero();
  
  // Validate ID format
  if (!id || typeof id !== 'string') {
    throw new Error('User ID is required and must be a string');
  }
  
  if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
    throw new Error('User ID must be a valid UUID');
  }

  try {
    await zero.mutate.users.delete({
      id
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to delete user: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


/**
 * Create or update a user (upsert operation)
 * 
 * @param data - The user data with optional ID for update, without ID for create
 * @returns Promise resolving to the user ID (generated if creating, provided if updating)
 * 
 * @example
 * ```typescript
 * import { upsertUser } from './user';
 * 
 * // Create new user (no ID provided)
 * const newResult = await upsertUser({
 *   // Add required fields here
 * });
 * 
 * // Update existing user (ID provided)
 * const updateResult = await upsertUser({
 *   id: '123e4567-e89b-12d3-a456-426614174000',
 *   // Add fields to update
 * });
 * ```
 */
export async function upsertUser(data: (CreateUserData & { id?: string }) | (UpdateUserData & { id: string })): Promise<UserMutationResult> {
  const zero = getZero();
  
  // Validate data is provided
  if (!data || Object.keys(data).length === 0) {
    throw new Error('Upsert data is required');
  }

  let id: string;
  const now = Date.now();

  // If ID is provided, validate it for update operation
  if (data.id) {
    if (!data.id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
      throw new Error('User ID must be a valid UUID');
    }
    id = data.id;
  } else {
    // Generate new ID for create operation
    id = crypto.randomUUID();
    if (!id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
      throw new Error('Failed to generate valid UUID');
    }
  }

  try {
    await zero.mutate.users.upsert({
      ...data,
      id,
      updated_at: now,
      // Set created_at only if this is a new record
      ...(data.id ? {} : { created_at: now }),
    });

    return { id };
  } catch (error) {
    throw new Error(`Failed to upsert user: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}


// Generated ActiveRecord-style queries for users


// Zero reactive query wrapper using materialize() for active queries
// This creates active queries that populate Zero's cache and stay synchronized
function createReactiveQuery<T>(queryBuilder: any, defaultValue: T) {
  let current = defaultValue;
  let resultType: 'loading' | 'success' | 'error' = 'loading';
  let error: Error | null = null;
  let view: any = null;
  let retryCount = 0;
  const maxRetries = 3;

  const execute = async () => {
    try {
      resultType = 'loading';
      
      // Check if Zero is ready
      const zero = getZero();
      if (!zero) {
        setTimeout(() => execute(), 100);
        return;
      }
      
      // Create active query using materialize()
      view = queryBuilder.materialize();
      const result = await view.data;
      
      // If result is null and we haven't retried much, try again
      if ((result === null || result === undefined) && retryCount < maxRetries) {
        retryCount++;
        setTimeout(() => execute(), 500);
        return;
      }
      
      current = result || defaultValue;
      resultType = 'success';
      error = null;
      retryCount = 0;
    } catch (err) {
      error = err instanceof Error ? err : new Error('Unknown error');
      resultType = 'error';
      
      // Retry on error if we haven't exceeded max retries
      if (retryCount < maxRetries) {
        retryCount++;
        setTimeout(() => execute(), 1000);
      }
    }
  };

  // Execute after a small delay to let Zero initialize
  setTimeout(() => execute(), 100);

  return {
    get current() { return current; },
    get value() { return current; },
    get resultType() { return resultType; },
    get error() { return error; },
    refresh: execute,
    destroy: () => view?.destroy()
  };
}

/**
 * ActiveRecord-style query interface for users
 * Provides offline-capable queries that work with Zero's local database
 */
export const User = {
  /**
   * Find a single user by ID
   * @param id - The UUID of the user
   * @returns Zero query result with the user or null
   * 
   * @example
   * ```typescript
   * const user = User.find('123e4567-e89b-12d3-a456-426614174000');
   * console.log(user.current); // The user object or null
   * ```
   */
  find(id: string) {
    const zero = getZero();
    if (!zero) return { current: null, value: null, resultType: 'loading' as const, error: null };
    
    return createReactiveQuery(
      zero.query.users.where('id', id).one(),
      null as User | null
    );
  },

  /**
   * Get all users
   * @returns Zero query result with array of users
   * 
   * @example
   * ```typescript
   * const allUsers = User.all();
   * console.log(allUsers.current); // Array of users
   * ```
   */
  all() {
    const zero = getZero();
    if (!zero) return { current: [], value: [], resultType: 'loading' as const, error: null };
    
    return createReactiveQuery(
              zero.query.users.orderBy('created_at', 'desc'),
              [] as User[]
            );
  },

  /**
   * Find users matching conditions
   * @param conditions - Object with field/value pairs to match
   * @returns Zero query result with array of matching users
   * 
   * @example
   * ```typescript
   * const activeUsers = User.where({ status: 'active' });
   * const clientJobs = User.where({ client_id: 'some-uuid' });
   * ```
   */
  where(conditions: Partial<User>) {
    const zero = getZero();
    if (!zero) return { current: [], value: [], resultType: 'loading' as const, error: null };
    
    let query = zero.query.users;
    
    Object.entries(conditions).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        query = query.where(key, value);
      }
    });
    
    return createReactiveQuery(
      query.orderBy('created_at', 'desc'),
      [] as User[]
    );
  }
};

